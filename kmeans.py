'''
kmeans implementation on grayscale image
This code is generated by LLM and is for learning purpose only
'''

import numpy as np
import cv2
import matplotlib.pyplot as plt



def initialize_centroids(pixels, k):
    # Randomly choose k pixels as initial centroids (here pixels are (row*col) 1d array
    # pixels.shape[0] is the number of rows
    random_indices = np.random.choice(pixels.shape[0], size=k, replace=False)
    centroids = pixels[random_indices]
    return centroids

def assign_clusters(pixels, centroids):
    """
    Assign each pixel to the nearest centroid based on Euclidean distance.

    Parameters:
    pixels (numpy.ndarray): A 2D array where each row represents a pixel's intensity value.
    centroids (numpy.ndarray): A 2D array where each row represents the intensity value of a centroid.

    Returns:
    numpy.ndarray: An array of cluster indices indicating which cluster each pixel belongs to.
    """
    
    # Initialize a list to store the distances from each pixel to each centroid
    distances = []
    
    # Loop through each centroid
    for centroid in centroids:
        # Calculate the squared differences between the centroid and each pixel
        # The result is a 2D array where each element is the squared difference
        squared_diff = (pixels - centroid) ** 2
        
        # Sum the squared differences to get the squared Euclidean distance
        # Since we are dealing with grayscale images, this is effectively summing a single value
        squared_distances = np.sum(squared_diff, axis=1)
        
        # Take the square root to get the actual Euclidean distance
        euclidean_distances = np.sqrt(squared_distances)
        
        # Append the distances for this centroid to the list of distances
        distances.append(euclidean_distances)
    
    # Convert the list of distances to a numpy array with shape (k, num_pixels)
    distances = np.array(distances)
    
    # For each pixel, find the index of the centroid with the smallest distance
    # This gives us the cluster assignment for each pixel
    clusters = np.argmin(distances, axis=0)
    
    return clusters

def update_centroids(pixels, clusters, k):
    """
    Update the centroids by calculating the mean of all pixels assigned to each centroid.

    Parameters:
    pixels (numpy.ndarray): A 2D array where each row represents a pixel's intensity value.
    clusters (numpy.ndarray): A 1D array where each element represents the cluster index assigned to a pixel.
    k (int): The number of clusters (centroids).

    Returns:
    numpy.ndarray: A 2D array where each row represents the updated centroid's intensity value.
    """
    
    # Initialize a list to store the new centroids
    new_centroids = []
    
    # Loop through each cluster index from 0 to k-1
    for i in range(k):
        # Select all pixels that belong to the current cluster (i)
        pixels_in_cluster = pixels[clusters == i]
        
        # Calculate the mean of the selected pixels along the 0th axis (mean of pixel intensities)
        # If there are no pixels in the cluster, the mean will return NaN, so we handle that case
        if len(pixels_in_cluster) > 0:
            centroid = pixels_in_cluster.mean(axis=0)
        else:
            # Handle the case where no pixels are assigned to the cluster
            # This can happen in some iterations of K-means, and it's common to leave the centroid unchanged
            # Here, we can either leave it as NaN and handle it later, or set it to zero.
            centroid = np.zeros(pixels.shape[1])  # Assuming grayscale images, so shape[1] should be 1
        
        # Append the calculated mean (centroid) to the list of new centroids
        new_centroids.append(centroid)
    
    # Convert the list of new centroids to a numpy array for consistency in data type
    new_centroids = np.array(new_centroids)
    
    return new_centroids


import numpy as np

def kmeans(pixels, k, max_iters=100, tolerance=1e-4):
    """
    Perform K-means clustering on image pixels.

    Parameters:
    pixels (numpy.ndarray): A 2D array where each row represents a pixel's intensity value.
    k (int): The number of clusters (centroids).
    max_iters (int, optional): The maximum number of iterations to run the algorithm. Default is 100.
    tolerance (float, optional): The convergence threshold. Default is 1e-4.

    Returns:
    tuple: A tuple containing:
        - clusters (numpy.ndarray): A 1D array where each element represents the cluster index assigned to a pixel.
        - centroids (numpy.ndarray): A 2D array where each row represents the final centroid's intensity value.
    """
    
    # Step 1: Initialize the centroids
    # The centroids are initialized by selecting k random points from the dataset
    centroids = initialize_centroids(pixels, k)
    
    # Step 2: Iterate through the maximum number of iterations or until convergence
    for iteration in range(max_iters):
        # Step 3: Assign each pixel to the nearest centroid
        # This creates a "clusters" array where each pixel is assigned to the index of the nearest centroid
        clusters = assign_clusters(pixels, centroids)
        
        # Step 4: Update the centroids based on the current cluster assignments
        # The new centroids are calculated by taking the mean of all pixels assigned to each centroid
        new_centroids = update_centroids(pixels, clusters, k)
        
        # Step 5: Check for convergence
        # Calculate the movement of centroids by finding the Euclidean distance between the old and new centroids
        # If the movement is less than the tolerance, the algorithm has converged, and we can stop iterating
        centroid_shift = np.linalg.norm(new_centroids - centroids)
        
        if centroid_shift < tolerance:
            # If the centroids have not moved significantly, break out of the loop
            break
        
        # Step 6: Update the centroids to the new values
        # If convergence has not been reached, set the current centroids to the new centroids
        centroids = new_centroids
    
    # Step 7: Return the final cluster assignments and centroids
    return clusters, centroids


# Load the image in grayscale
image = cv2.imread('three-color.jpg', cv2.IMREAD_GRAYSCALE)

# Display the original image
plt.imshow(image, cmap='gray')
plt.title('Original Grayscale Image')
plt.show()

# Reshape the image to a 2D array of pixels
pixels = image.reshape(-1, 1)

# Define the number of clusters (e.g., 3 clusters)
n_clusters = 3

# Run K-means clustering
clusters, centroids = kmeans(pixels, n_clusters)

# Replace each pixel value with its corresponding centroid value
clustered_pixels = centroids[clusters].reshape(image.shape)

# Display the clustered image
plt.imshow(clustered_pixels, cmap='gray')
plt.title('Clustered Image')
plt.show()
